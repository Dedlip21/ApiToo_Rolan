import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, p as handle_promise, r as empty, m as insert_hydration_dev, o as noop, b as detach_dev, u as update_await_block_branch, w as validate_each_argument, e as element, t as text, a as space, f as claim_element, g as children, h as claim_text, c as claim_space, x as set_style, k as add_location, n as append_hydration_dev, y as destroy_each, j as attr_dev } from './client.8ff73872.js';
import { p as post } from './utils.c922ace3.js';

/* src\routes\overview.svelte generated by Svelte v3.50.1 */
const file = "src\\routes\\overview.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	return child_ctx;
}

// (21:0) {#if true}
function create_if_block(ctx) {
	let await_block_anchor;

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: false,
		pending: create_pending_block,
		then: create_then_block,
		catch: create_catch_block_1,
		value: 2
	};

	handle_promise(/*getMyData*/ ctx[0](), info);

	const block = {
		c: function create() {
			await_block_anchor = empty();
			info.block.c();
		},
		l: function claim(nodes) {
			await_block_anchor = empty();
			info.block.l(nodes);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, await_block_anchor, anchor);
			info.block.m(target, info.anchor = anchor);
			info.mount = () => await_block_anchor.parentNode;
			info.anchor = await_block_anchor;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			update_await_block_branch(info, ctx, dirty);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(await_block_anchor);
			info.block.d(detaching);
			info.token = null;
			info = null;
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(21:0) {#if true}",
		ctx
	});

	return block;
}

// (1:0) <script context="module">      export async function preload({params}
function create_catch_block_1(ctx) {
	const block = {
		c: noop,
		l: noop,
		m: noop,
		p: noop,
		d: noop
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_catch_block_1.name,
		type: "catch",
		source: "(1:0) <script context=\\\"module\\\">      export async function preload({params}",
		ctx
	});

	return block;
}

// (24:4) {:then my}
function create_then_block(ctx) {
	let section0;
	let p0;
	let t0_value = /*my*/ ctx[2].name + "";
	let t0;
	let t1;
	let section1;
	let t2;
	let p1;
	let t3_value = /*my*/ ctx[2].funds + "";
	let t3;
	let t4;
	let section2;
	let ul;
	let t5;
	let section3;
	let each_value_1 = /*my*/ ctx[2].accounts;
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: false,
		pending: create_pending_block_1,
		then: create_then_block_1,
		catch: create_catch_block,
		value: 3
	};

	handle_promise(/*getTransactions*/ ctx[1](), info);

	const block = {
		c: function create() {
			section0 = element("section");
			p0 = element("p");
			t0 = text(t0_value);
			t1 = space();
			section1 = element("section");
			t2 = text("My funds\r\n            ");
			p1 = element("p");
			t3 = text(t3_value);
			t4 = space();
			section2 = element("section");
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t5 = space();
			section3 = element("section");
			info.block.c();
			this.h();
		},
		l: function claim(nodes) {
			section0 = claim_element(nodes, "SECTION", {});
			var section0_nodes = children(section0);
			p0 = claim_element(section0_nodes, "P", { style: true });
			var p0_nodes = children(p0);
			t0 = claim_text(p0_nodes, t0_value);
			p0_nodes.forEach(detach_dev);
			section0_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			section1 = claim_element(nodes, "SECTION", {});
			var section1_nodes = children(section1);
			t2 = claim_text(section1_nodes, "My funds\r\n            ");
			p1 = claim_element(section1_nodes, "P", { style: true });
			var p1_nodes = children(p1);
			t3 = claim_text(p1_nodes, t3_value);
			p1_nodes.forEach(detach_dev);
			section1_nodes.forEach(detach_dev);
			t4 = claim_space(nodes);
			section2 = claim_element(nodes, "SECTION", {});
			var section2_nodes = children(section2);
			ul = claim_element(section2_nodes, "UL", {});
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			section2_nodes.forEach(detach_dev);
			t5 = claim_space(nodes);
			section3 = claim_element(nodes, "SECTION", {});
			var section3_nodes = children(section3);
			info.block.l(section3_nodes);
			section3_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(p0, "font-size", "xx-large");
			add_location(p0, file, 25, 12, 657);
			add_location(section0, file, 24, 8, 634);
			set_style(p1, "font-size", "xx-large");
			set_style(p1, "color", /*my*/ ctx[2].funds >= 0 ? 'green' : 'red');
			add_location(p1, file, 29, 12, 776);
			add_location(section1, file, 27, 8, 731);
			add_location(ul, file, 32, 12, 915);
			add_location(section2, file, 31, 8, 892);
			add_location(section3, file, 38, 8, 1105);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, section0, anchor);
			append_hydration_dev(section0, p0);
			append_hydration_dev(p0, t0);
			insert_hydration_dev(target, t1, anchor);
			insert_hydration_dev(target, section1, anchor);
			append_hydration_dev(section1, t2);
			append_hydration_dev(section1, p1);
			append_hydration_dev(p1, t3);
			insert_hydration_dev(target, t4, anchor);
			insert_hydration_dev(target, section2, anchor);
			append_hydration_dev(section2, ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			insert_hydration_dev(target, t5, anchor);
			insert_hydration_dev(target, section3, anchor);
			info.block.m(section3, info.anchor = null);
			info.mount = () => section3;
			info.anchor = null;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*getMyData*/ 1) {
				each_value_1 = /*my*/ ctx[2].accounts;
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}

			update_await_block_branch(info, ctx, dirty);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section0);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(section1);
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(section2);
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(t5);
			if (detaching) detach_dev(section3);
			info.block.d();
			info.token = null;
			info = null;
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_then_block.name,
		type: "then",
		source: "(24:4) {:then my}",
		ctx
	});

	return block;
}

// (34:16) {#each my.accounts as account}
function create_each_block_1(ctx) {
	let li;
	let t0_value = /*account*/ ctx[7].number + "";
	let t0;
	let t1;
	let t2_value = /*account*/ ctx[7].name + "";
	let t2;
	let t3;

	const block = {
		c: function create() {
			li = element("li");
			t0 = text(t0_value);
			t1 = text(" (");
			t2 = text(t2_value);
			t3 = text(")");
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", {});
			var li_nodes = children(li);
			t0 = claim_text(li_nodes, t0_value);
			t1 = claim_text(li_nodes, " (");
			t2 = claim_text(li_nodes, t2_value);
			t3 = claim_text(li_nodes, ")");
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(li, file, 34, 20, 989);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, li, anchor);
			append_hydration_dev(li, t0);
			append_hydration_dev(li, t1);
			append_hydration_dev(li, t2);
			append_hydration_dev(li, t3);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(34:16) {#each my.accounts as account}",
		ctx
	});

	return block;
}

// (1:0) <script context="module">      export async function preload({params}
function create_catch_block(ctx) {
	const block = {
		c: noop,
		l: noop,
		m: noop,
		p: noop,
		d: noop
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_catch_block.name,
		type: "catch",
		source: "(1:0) <script context=\\\"module\\\">      export async function preload({params}",
		ctx
	});

	return block;
}

// (42:12) {:then transactions}
function create_then_block_1(ctx) {
	let table;
	let thead;
	let tr;
	let th0;
	let t0;
	let t1;
	let th1;
	let t2;
	let t3;
	let th2;
	let t4;
	let t5;
	let th3;
	let t6;
	let t7;
	let tbody;
	let each_value = /*transactions*/ ctx[3];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			table = element("table");
			thead = element("thead");
			tr = element("tr");
			th0 = element("th");
			t0 = text("senderName");
			t1 = space();
			th1 = element("th");
			t2 = text("amount");
			t3 = space();
			th2 = element("th");
			t4 = text("createdAt");
			t5 = space();
			th3 = element("th");
			t6 = text("status");
			t7 = space();
			tbody = element("tbody");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			table = claim_element(nodes, "TABLE", { class: true });
			var table_nodes = children(table);
			thead = claim_element(table_nodes, "THEAD", {});
			var thead_nodes = children(thead);
			tr = claim_element(thead_nodes, "TR", {});
			var tr_nodes = children(tr);
			th0 = claim_element(tr_nodes, "TH", {});
			var th0_nodes = children(th0);
			t0 = claim_text(th0_nodes, "senderName");
			th0_nodes.forEach(detach_dev);
			t1 = claim_space(tr_nodes);
			th1 = claim_element(tr_nodes, "TH", {});
			var th1_nodes = children(th1);
			t2 = claim_text(th1_nodes, "amount");
			th1_nodes.forEach(detach_dev);
			t3 = claim_space(tr_nodes);
			th2 = claim_element(tr_nodes, "TH", {});
			var th2_nodes = children(th2);
			t4 = claim_text(th2_nodes, "createdAt");
			th2_nodes.forEach(detach_dev);
			t5 = claim_space(tr_nodes);
			th3 = claim_element(tr_nodes, "TH", {});
			var th3_nodes = children(th3);
			t6 = claim_text(th3_nodes, "status");
			th3_nodes.forEach(detach_dev);
			tr_nodes.forEach(detach_dev);
			thead_nodes.forEach(detach_dev);
			t7 = claim_space(table_nodes);
			tbody = claim_element(table_nodes, "TBODY", {});
			var tbody_nodes = children(tbody);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(tbody_nodes);
			}

			tbody_nodes.forEach(detach_dev);
			table_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(th0, file, 45, 24, 1365);
			add_location(th1, file, 46, 24, 1410);
			add_location(th2, file, 47, 24, 1451);
			add_location(th3, file, 48, 24, 1495);
			add_location(tr, file, 44, 20, 1335);
			add_location(thead, file, 43, 20, 1306);
			add_location(tbody, file, 51, 20, 1589);
			attr_dev(table, "class", "table table-striped table-bordered");
			add_location(table, file, 42, 16, 1234);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, table, anchor);
			append_hydration_dev(table, thead);
			append_hydration_dev(thead, tr);
			append_hydration_dev(tr, th0);
			append_hydration_dev(th0, t0);
			append_hydration_dev(tr, t1);
			append_hydration_dev(tr, th1);
			append_hydration_dev(th1, t2);
			append_hydration_dev(tr, t3);
			append_hydration_dev(tr, th2);
			append_hydration_dev(th2, t4);
			append_hydration_dev(tr, t5);
			append_hydration_dev(tr, th3);
			append_hydration_dev(th3, t6);
			append_hydration_dev(table, t7);
			append_hydration_dev(table, tbody);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tbody, null);
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*getTransactions*/ 2) {
				each_value = /*transactions*/ ctx[3];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tbody, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(table);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_then_block_1.name,
		type: "then",
		source: "(42:12) {:then transactions}",
		ctx
	});

	return block;
}

// (53:24) {#each transactions as transaction}
function create_each_block(ctx) {
	let tr;
	let td0;
	let b0;
	let t0_value = /*transaction*/ ctx[4].senderName + "";
	let t0;
	let br0;
	let t1_value = /*transaction*/ ctx[4].explanation + "";
	let t1;
	let t2;
	let td1;
	let t3_value = /*transaction*/ ctx[4].amount + "";
	let t3;
	let t4;
	let t5_value = /*transaction*/ ctx[4].currency + "";
	let t5;
	let t6;
	let td2;
	let t7_value = /*transaction*/ ctx[4].createdAt + "";
	let t7;
	let t8;
	let td3;
	let b1;
	let t9_value = /*transaction*/ ctx[4].status + "";
	let t9;
	let br1;
	let t10_value = /*transaction*/ ctx[4].statusDetail + "";
	let t10;
	let t11;

	const block = {
		c: function create() {
			tr = element("tr");
			td0 = element("td");
			b0 = element("b");
			t0 = text(t0_value);
			br0 = element("br");
			t1 = text(t1_value);
			t2 = space();
			td1 = element("td");
			t3 = text(t3_value);
			t4 = space();
			t5 = text(t5_value);
			t6 = space();
			td2 = element("td");
			t7 = text(t7_value);
			t8 = space();
			td3 = element("td");
			b1 = element("b");
			t9 = text(t9_value);
			br1 = element("br");
			t10 = text(t10_value);
			t11 = space();
			this.h();
		},
		l: function claim(nodes) {
			tr = claim_element(nodes, "TR", {});
			var tr_nodes = children(tr);
			td0 = claim_element(tr_nodes, "TD", {});
			var td0_nodes = children(td0);
			b0 = claim_element(td0_nodes, "B", {});
			var b0_nodes = children(b0);
			t0 = claim_text(b0_nodes, t0_value);
			b0_nodes.forEach(detach_dev);
			br0 = claim_element(td0_nodes, "BR", {});
			t1 = claim_text(td0_nodes, t1_value);
			td0_nodes.forEach(detach_dev);
			t2 = claim_space(tr_nodes);
			td1 = claim_element(tr_nodes, "TD", { style: true });
			var td1_nodes = children(td1);
			t3 = claim_text(td1_nodes, t3_value);
			t4 = claim_space(td1_nodes);
			t5 = claim_text(td1_nodes, t5_value);
			td1_nodes.forEach(detach_dev);
			t6 = claim_space(tr_nodes);
			td2 = claim_element(tr_nodes, "TD", {});
			var td2_nodes = children(td2);
			t7 = claim_text(td2_nodes, t7_value);
			td2_nodes.forEach(detach_dev);
			t8 = claim_space(tr_nodes);
			td3 = claim_element(tr_nodes, "TD", {});
			var td3_nodes = children(td3);
			b1 = claim_element(td3_nodes, "B", {});
			var b1_nodes = children(b1);
			t9 = claim_text(b1_nodes, t9_value);
			b1_nodes.forEach(detach_dev);
			br1 = claim_element(td3_nodes, "BR", {});
			t10 = claim_text(td3_nodes, t10_value);
			td3_nodes.forEach(detach_dev);
			t11 = claim_space(tr_nodes);
			tr_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(b0, file, 54, 36, 1729);
			add_location(br0, file, 54, 67, 1760);
			add_location(td0, file, 54, 32, 1725);
			set_style(td1, "color", /*transaction*/ ctx[4].amount >= 0 ? 'green' : 'red');
			add_location(td1, file, 55, 32, 1828);
			add_location(td2, file, 56, 32, 1972);
			add_location(b1, file, 57, 36, 2042);
			add_location(br1, file, 57, 63, 2069);
			add_location(td3, file, 57, 32, 2038);
			add_location(tr, file, 53, 28, 1687);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, tr, anchor);
			append_hydration_dev(tr, td0);
			append_hydration_dev(td0, b0);
			append_hydration_dev(b0, t0);
			append_hydration_dev(td0, br0);
			append_hydration_dev(td0, t1);
			append_hydration_dev(tr, t2);
			append_hydration_dev(tr, td1);
			append_hydration_dev(td1, t3);
			append_hydration_dev(td1, t4);
			append_hydration_dev(td1, t5);
			append_hydration_dev(tr, t6);
			append_hydration_dev(tr, td2);
			append_hydration_dev(td2, t7);
			append_hydration_dev(tr, t8);
			append_hydration_dev(tr, td3);
			append_hydration_dev(td3, b1);
			append_hydration_dev(b1, t9);
			append_hydration_dev(td3, br1);
			append_hydration_dev(td3, t10);
			append_hydration_dev(tr, t11);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(53:24) {#each transactions as transaction}",
		ctx
	});

	return block;
}

// (40:38)                   Loading...              {:then transactions}
function create_pending_block_1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Loading...");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Loading...");
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_pending_block_1.name,
		type: "pending",
		source: "(40:38)                   Loading...              {:then transactions}",
		ctx
	});

	return block;
}

// (22:24)           Loading...      {:then my}
function create_pending_block(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Loading...");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Loading...");
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_pending_block.name,
		type: "pending",
		source: "(22:24)           Loading...      {:then my}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let if_block_anchor;
	let if_block = create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_hydration_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, [dirty]) {
			if_block.p(ctx, dirty);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function preload({ params }, { token }) {
	if (!token) {
		this.redirect(302, `/login`);
	}
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Overview', slots, []);

	async function getMyData() {
		return await post(`auth/getMyData`).then(r => {
			r.funds = r.accounts.reduce((funds, account) => funds + account.balance, 0);
			return r;
		});
	}

	async function getTransactions() {
		return await post(`auth/getTransactions`);
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Overview> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		preload,
		post,
		getMyData,
		getTransactions
	});

	return [getMyData, getTransactions];
}

class Overview extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Overview",
			options,
			id: create_fragment.name
		});
	}
}

export { Overview as default, preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3ZlcnZpZXcuZDU2YzM0NGEuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yb3V0ZXMvb3ZlcnZpZXcuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQgY29udGV4dD1cIm1vZHVsZVwiPlxyXG4gICAgZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByZWxvYWQoe3BhcmFtc30sIHt0b2tlbn0pIHtcclxuICAgICAgICBpZiAoIXRva2VuKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVkaXJlY3QoMzAyLCBgL2xvZ2luYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG48L3NjcmlwdD5cclxuPHNjcmlwdD5cclxuICAgIGltcG9ydCB7cG9zdH0gZnJvbSAndXRpbHMuanMnO1xyXG5cclxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldE15RGF0YSgpe1xyXG4gICAgICAgIHJldHVybiBhd2FpdCBwb3N0KGBhdXRoL2dldE15RGF0YWApLnRoZW4ocj0+e1xyXG4gICAgICAgICAgICByLmZ1bmRzID0gci5hY2NvdW50cy5yZWR1Y2UoKGZ1bmRzLCBhY2NvdW50KSA9PiBmdW5kcyArIGFjY291bnQuYmFsYW5jZSwgMClcclxuICAgICAgICAgICAgcmV0dXJuIHJcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25zKCl7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHBvc3QoYGF1dGgvZ2V0VHJhbnNhY3Rpb25zYClcclxuICAgIH1cclxuPC9zY3JpcHQ+XHJcbnsjaWYgcHJvY2Vzcy5icm93c2VyfVxyXG4gICAgeyNhd2FpdCBnZXRNeURhdGEoKX1cclxuICAgICAgICBMb2FkaW5nLi4uXHJcbiAgICB7OnRoZW4gbXl9XHJcbiAgICAgICAgPHNlY3Rpb24+XHJcbiAgICAgICAgICAgIDxwIHN0eWxlPVwiZm9udC1zaXplOiB4eC1sYXJnZVwiPntteS5uYW1lfTwvcD5cclxuICAgICAgICA8L3NlY3Rpb24+XHJcbiAgICAgICAgPHNlY3Rpb24+XHJcbiAgICAgICAgICAgIE15IGZ1bmRzXHJcbiAgICAgICAgICAgIDxwIHN0eWxlPVwiZm9udC1zaXplOiB4eC1sYXJnZTsgY29sb3I6IHtteS5mdW5kcyA+PSAwID8gJ2dyZWVuJzogJ3JlZCd9XCI+e215LmZ1bmRzfTwvcD5cclxuICAgICAgICA8L3NlY3Rpb24+XHJcbiAgICAgICAgPHNlY3Rpb24+XHJcbiAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgIHsjZWFjaCBteS5hY2NvdW50cyBhcyBhY2NvdW50fVxyXG4gICAgICAgICAgICAgICAgICAgIDxsaT57YWNjb3VudC5udW1iZXJ9ICh7YWNjb3VudC5uYW1lfSk8L2xpPlxyXG4gICAgICAgICAgICAgICAgey9lYWNofVxyXG4gICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgIDwvc2VjdGlvbj5cclxuICAgICAgICA8c2VjdGlvbj5cclxuICAgICAgICAgICAgeyNhd2FpdCBnZXRUcmFuc2FjdGlvbnMoKX1cclxuICAgICAgICAgICAgICAgIExvYWRpbmcuLi5cclxuICAgICAgICAgICAgezp0aGVuIHRyYW5zYWN0aW9uc31cclxuICAgICAgICAgICAgICAgIDx0YWJsZSBjbGFzcz1cInRhYmxlIHRhYmxlLXN0cmlwZWQgdGFibGUtYm9yZGVyZWRcIj5cclxuICAgICAgICAgICAgICAgICAgICA8dGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRyPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGg+c2VuZGVyTmFtZTwvdGg+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aD5hbW91bnQ8L3RoPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGg+Y3JlYXRlZEF0PC90aD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoPnN0YXR1czwvdGg+XHJcbiAgICAgICAgICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgICAgICAgICAgICA8L3RoZWFkPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0Ym9keT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgeyNlYWNoIHRyYW5zYWN0aW9ucyBhcyB0cmFuc2FjdGlvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+PGI+e3RyYW5zYWN0aW9uLnNlbmRlck5hbWV9PC9iPjxicj57dHJhbnNhY3Rpb24uZXhwbGFuYXRpb259PC90ZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgc3R5bGU9XCJjb2xvcjoge3RyYW5zYWN0aW9uLmFtb3VudCA+PSAwID8gJ2dyZWVuJzogJ3JlZCd9XCI+e3RyYW5zYWN0aW9uLmFtb3VudH0ge3RyYW5zYWN0aW9uLmN1cnJlbmN5fTwvdGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPnt0cmFuc2FjdGlvbi5jcmVhdGVkQXR9PC90ZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+PGI+e3RyYW5zYWN0aW9uLnN0YXR1c308L2I+PGJyPnt0cmFuc2FjdGlvbi5zdGF0dXNEZXRhaWx9PC90ZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsvZWFjaH1cclxuICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxyXG4gICAgICAgICAgICAgICAgPC90YWJsZT5cclxuICAgICAgICAgICAgICAgIHsvYXdhaXR9XHJcbiAgICAgICAgPC9zZWN0aW9uPlxyXG4gICAgey9hd2FpdH1cclxuey9pZn0iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhCQXFCWSxHQUFTLENBQUEsQ0FBQSxDQUFBLEVBQUEsRUFBQSxJQUFBLENBQUEsQ0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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
